<Lesson>
<H> 
	<C> PowerShell Orientation </C>
	<L> Pattern Matching and Replacement </L>
</H>
<B>
	<S> 
		<N> </N>

		// minimal
		<T> 
			<P> 
			</P>
		</T>

		// fully fleshed out
		<T> 
			<P> 
			</P>
			<opt> </opt>
			<soln> 
				<expr> </expr>
				<exec> </exec>
			</soln>
			<code> 
				<block> </block>
				<var> </var>
			</code>
		</T>
	</S>
	<S> 
		<N> Main </N>
		<T> 
			<P> 
				Two common tasks you'll encounter everywhere in PowerShell, from core built-in commands to third-party management modules, are pattern matching and replacement. 
			</P>
		</T>
		<T> 
			<P> 
				Pattern matching is the act of searching a body of text or objects with text data for some pattern, and doing something depending on whether the text being searched matches the pattern. Replacement is pattern matching that involves actually changing the text that matches your pattern. 
			</P>
		</T>
		<T> 
			<P>
				As an example, suppose you want to list the files in a directory that have file extension .txt. Since you don't know ahead of time what the names of the files are, you have to create a pattern which will match those files that have file extension .txt and not match those files that have other extensions. 
			</P>
		</T>
		<T> 
			<P> 
				We can use Get-ChildItem as our search directory command with the pattern '*.txt' to get the files we need. The '*' within the pattern is a wildcard, which as its name suggests, can take the form of any file name. The entire pattern can be read as meaning any string, followed by a period, followed by the string 'txt'. It's easy to see that all .txt files and only .txt files will match this pattern. 

				The command 'Get-ChildItem *.txt' can be used to accomplish our original task. 
			</P>
		</T>
		<T> 
			<P> 
				I've created a number of empty files with different extensions in the PSwirlDrive:\ directory for you to play with. 

				Type 'Get-ChildItem' or the shorthand 'gci' to see the files that are there.
			</P>
			<opt> pc </opt>
			<code> 
				<block> New-PSwirlDrive; 
						Set-Location ((Get-PSwirlDriveName) + ":\");
						(1..3) | % {ni "script$_.sql"} | out-null
						(1..4) | % {ni "text$_.txt"} | out-null
						(1..2) | % {ni "data$_.csv"} | out-null
				</block>
			</code>
		</T>
		<T> 
			<P> 
				Using a pattern similar to the one we used to find the .txt files before, use
				Get-ChildItem to list all the files which have the type extension ".sql"
			</P>
			<opt> ps </opt>
			<soln> 
				<expr> gci *.sql </expr>
				<exec> 1 </exec>
			</soln>
		</T>
		<T> 
			<P> 
				The '*' wildcard can be placed anywhere in the pattern string any number of times, or omitted altogther. When the '*' is not used, the pattern must be exact (while still being case insensitive by default)
			</P>
		</T>
		<T> 
			<P> 
				For example, if you want to search for only for a file named 'error_log.txt', you could use the command 'Get-ChildItem error_log.txt'. On the other hand, if you wanted to find all .txt files which had the string 'log' in the name, you could use the command 'Get-ChildItem *log*.txt''.
			</P>
		</T>
		<T> 
			<P> 
				Type a command you could use to find all files in the directory from before with at least one '2' character in the name. The files in the list can be of any type extension.
			</P>
			<opt> ps </opt>
			<soln> 
				<expr> gci *2* </expr>
				<exec> 1 </exec>
			</soln>
		</T>
		<T>
			<P> 
				The * wildcard is probably the most common wildcard to use in day-to-day PowerShell work, but there are others available. For more information, type the command 'help about_wildcards'. 
			</P>
			<opt> p </opt>
		</T>
		<T>
			<P> 
				While '*' and its cousins '?' and '[]' are usually enough for matching type extensions and substrings, there are many patterns that are difficult to capture succinctly with these tools. 
			</P>
		</T>
		<T> 
			<P> 
				Take for example the problem of looking for text files which end in a number that can be anywhere between 1 and 100, where the numbers are not padded with 0's as in file001.txt. Using just the tools we've considered before, you might try to capture this with 3 patterns, one for digits 1-9, one for digits 10-99, and one for digits 100. The patterns would be *[1-9].txt, *[1-9][0-9].txt, and *100.txt, respectively.
				This is both verbose and incorrect. It's verbose because it requires 3 patterns instead of 1, even though the pattern can be described informally without reference to 3 patterns. It is incorrect because the * picks up any additional numbers to the left of the numbers at the end, so files like 'file15159100.txt' would match the pattern. We can remedy this problem by specifying all the non-digit characters that can occur before the last digit characters, but this would be difficult and even more verbose. 
			</P>
		</T>
		<T> 
			<P> 
				To address the verbosity and incorrectness of our approach so far, we should ideally be able to express patterns that have what we'll call alternation, negation, and abbreviated character sets. Let's consider the meaning of each of these. 
			</P>
		</T>
		<T>
			<P> 
				Alternation is the ability to express a list of patterns and say that the string matches the pattern if it matches at least one pattern, but possibly more. 
				Having alternation means that we don't have to have 3 separate patterns for matching 
				the 3 cases mentioned above. Instead we could have one pattern that matches the numbers 1 though 100 through alternation and we could embed this pattern within the 
				larger pattern. 
			</P>
		</T>		
		<T> 
			<P> 
				Negation is the ability to express that a pattern or subpattern does NOT match some pattern that we specify. In our example, we see a simple case where we'd want to be able to use negation: we want any characters before the number portion of the filename to be not decimal digits. 
			</P>
		</T>
		<T> 
			<P> 
				Finally, abbreviated character sets would allow us to specify common character choices like [0-9] and [a-z] with fewer characters. Ideally each of these common sets could be abbreviated with 1 or 2 characters that can be reused anywhere in the pattern. 
			</P>
		</T>
		<T> 
			<P> 
				Alternation, negation, and abbreviated character sets, along with a wide variety of other features, are available in a widely used language called regular expressions, or regex for short. There are different versions of regex for different platforms, but they're more or less the same. Since this is a course on PowerShell, a .NET based language, we will consider .NET regular expressions and how they can be used to solve problems in PowerShell.
			</P>
		</T>
		<T> 
			<P> 
				Let's reconsider each of the 3 language features we have just introduced and how their realization in regex can help us solve our file query problem.  
			</P>
		</T>
		<T> 
			<P> 
				As we alluded to before, alternation can be used to express the different cases for numbers 1-100. In regex, the '|' symbol is the symbol used to denote alternation.
				Using the character sets [1-9] and [0-9] to denote the decimal digits 1-9 and the decimal digits 0-9 respectively, and using () to group each case into its own pattern, we obtain the following regex for the number portion: "(100)|([1-9][0-9])|([1-9])". Later we'll see how we can combine this with the other parts of the pattern so that we need only 1 pattern to match all 3 cases. 
			</P>
		</T>
		<T> 
			<P> 
				Our inability to use negation led us to the problem of passing filenames like "data91584.txt". Using our non-regex approach, the * wildcard matches the "data915" portion of the filename and the explicitly listed patterns match the rest of the string. But we only wanted filenames with numbers between 1 and 100. 
				In regex, the negation symbol is '^'. So the character set which includes all characters which are NOT digits is [^0-9]. Combining this with the regex we have so far, we obtain "[^0-9](100)|([1-9][0-9])|([1-9])". This pattern matches strings which have a non-digit character, followed by a string of digits that represent numbers 1 through 100. 
			</P>
		</T>
		<T> 
			<P> 
				Finally, we can use abbreviated character sets in regex to simplify what we have so far. The character sets [0-9] is so common that it has its own special symbol, \d, where the 'd' stands for digit. Further, the character set containing characters not in \d is denoted by \D. Using these facts, we can change our regex to "\D((100)|([1-9]\d)|([1-9])". 
			</P>
		</T>
		<T> 
			<P> 
				Now that we have a compact regex pattern for the tricky number pattern we've been dealing with, we can complete our regular expression with the type extension and the part of the filename that precedes the numbers (if it exists). 
			</P>
		</T>
	</S>
</B>
</Lesson>